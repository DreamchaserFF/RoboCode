package FOX2;//pacote do meu robo


import robocode.*;//importação do robocode
import static robocode.util.Utils.normalRelativeAngleDegrees; //torna os angulos normais em relativos, permitindo a movimentação em espiral
import java.awt.*;//importação padrão gráfica do java
import robocode.Robot;
import robocode.HitRobotEvent;
import robocode.ScannedRobotEvent;
import robocode.WinEvent;
import robocode.HitWallEvent;

public class FOX2 extends AdvancedRobot {
	boolean movingForward;
	boolean inWall; // // coloca como "true" assim que o robo esta perto da parede, possibilitando determinar comandos como onHitWall.
// O comando "inwall = true" vai definir se ele está distante 50px, senão (else) "inwall = false"
	


	public void run() {
		// Set colors
		setColors(Color.gray,Color.black,Color.orange,Color.orange,Color.green);
		setMaxVelocity(1000);

		//	Torna cada elemento do robo independente
		setAdjustRadarForRobotTurn(true);
		setAdjustGunForRobotTurn(true);
		setAdjustRadarForGunTurn(true);
		
	// Como eu não quero que o robo acerte a parede ou enfrente algo relacionado a parede, o robo continuamente fica checando se está a 50px da parede
		if (getX() <= 50 || getY() <= 50 || getBattleFieldWidth() - getX() <= 50 || getBattleFieldHeight() - getY() <= 50) {
				inWall = true;
			} else {
			inWall = false;
		}
		boolean peek; // Nao virar se houver um robo ali
	double moveAmount; // O quanto se mover
	/**
	 * run: Mover pelas paredes
	 */

		// Colocar moveAmount para o maximo possivel do campo
		moveAmount = Math.max(getBattleFieldWidth(), getBattleFieldHeight());
		// Colocar peek como falso
		peek = false;

		// turnLeft para encarar parede.
		// getHeading() % 90 quer dizer o restante
		// getHeading() dividido por 90
		turnLeft(getHeading() % 90);
		ahead(moveAmount);
		// Virar a arma 90 graus pra direita
		peek = true;
		turnGunRight(90);
		turnRight(90);

		while (true) {
			// Olhar antes de virar quando ahead() completar
			peek = true;
			// Ir pra parede
			ahead(moveAmount);
			// Não procurar inimigo agora
			peek = false;
			// Virar pra próxima parede
			turnRight(90);
			if (getRadarTurnRemaining() == 0.0){
			setTurnRadarRight(360);
			}
			
			execute(); // executa
		}
	}

	
			
	/**
	 * onHitRobot:  Voltar um pouco.
	 */
	public void onHitRobot(HitRobotEvent e) {
		// Se houver um inimigo na nossa frente, voltar um pouco pra trás.
		if (e.getBearing() > -90 && e.getBearing() < 90) {
			back(100);
		} // Se ele estiver atras de nos, ir pra frente.
		else {
			ahead(100);
			}
			// garante que se o radar parar, o robo vai procurar outro inimigo
		
		}

	
	public void onScannedRobot(ScannedRobotEvent e) {
		// calcula a localizacao exata do robo inimigo escaneado
		double absoluteBearing = getHeading() + e.getBearing();
		double bearingFromGun = normalRelativeAngleDegrees(absoluteBearing - getGunHeading());
		double bearingFromRadar = normalRelativeAngleDegrees(absoluteBearing - getRadarHeading());
		

		// perto o suficiente? atire
	
			setTurnGunRight(bearingFromGun); 
			setTurnRadarRight(bearingFromRadar);	
					//mantem o radar no inimigo
			
			
		if (getGunHeat() == 0 && getEnergy() > .2) { 
				fire(Math.min(4.5 - Math.abs(bearingFromGun) / 2 - e.getDistance() / 250, getEnergy() - .1));
			} 
			
		else {
			setTurnGunRight(bearingFromGun);
			setTurnRadarRight(bearingFromRadar);
		}
		// gera outro scan, se ver outro robo
		// AVISO -----------------> É SÓ UMA PRECAUÇÃO, CASO O RADAR FALHE!
		if (bearingFromGun == 4) {
			scan();
		}
	}
}	

	/**
	 * onHitRobot:  recua
	 */


